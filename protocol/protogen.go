package main

import (
	"encoding/xml"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

var baseDomainsMap = map[string]string{
	"octet":     "byte",
	"short":     "uint16",
	"long":      "uint32",
	"longlong":  "uint64",
	"timestamp": "time.Time",
	"shortstr":  "string",
	"longstr":   "[]byte",
	"bit":       "bool",
	"table":     "*Table",
}

type Amqp struct {
	Constants []*Constant `xml:"constant"`
	Domains   []*Domain   `xml:"domain"`
	Classes   []*Class    `xml:"class"`
}

type Constant struct {
	Name        string `xml:"name,attr"`
	Value       uint16 `xml:"value,attr"`
	Doc         string `xml:"doc"`
	GoName      string
	GoStr       string
	IgnoreOnMap bool
}

type Domain struct {
	Name   string `xml:"name,attr"`
	Type   string `xml:"type,attr"`
	GoName string
	GoType string
}

type Class struct {
	Name    string    `xml:"name,attr"`
	ID      uint16    `xml:"index,attr"`
	Methods []*Method `xml:"method"`
	Fields  []*Field  `xml:"field"`
	GoName  string
}

type Method struct {
	Name        string   `xml:"name,attr"`
	ID          uint16   `xml:"index,attr"`
	Fields      []*Field `xml:"field"`
	GoName      string
	Doc         string   `xml:"doc"`
	Synchronous byte     `xml:"synchronous,attr"`
}

type Field struct {
	Name        string `xml:"name,attr"`
	Domain      string `xml:"domain,attr"`
	Type        string `xml:"type,attr"`
	GoName      string
	GoType      string
	ReaderFunc  string
	IsBit       bool
	BitOrder    int
	LastBit     bool
	HeaderIndex int
}

func (amqp Amqp) SaveConstants(wr io.Writer) {
	const constTemplate = `
// Autogenerated code. Do not edit.
package amqp
{{range .}}
{{.Doc}}
const {{.GoName}} = {{.Value}}
{{end}}

var ConstantsNameMap = map[uint16]string{
{{range .}}
{{if eq .IgnoreOnMap false}}
{{.Value}}: "{{.GoStr}}",{{end}}
{{end}}
}
`
	t := template.Must(template.New("constTemplate").Parse(constTemplate))

	for _, class := range amqp.Classes {
		constant := &Constant{Name: strings.Join([]string{"class", class.Name}, "-"), Value: class.ID, IgnoreOnMap: true}
		amqp.Constants = append(amqp.Constants, constant)

		for _, method := range class.Methods {
			constant := &Constant{Name: strings.Join([]string{"method", class.Name, method.Name}, "-"), Value: method.ID, IgnoreOnMap: true}
			amqp.Constants = append(amqp.Constants, constant)
		}
	}

	for _, constant := range amqp.Constants {
		constant.GoName = kebabToCamel(constant.Name)
		constant.GoStr = kebabToStr(constant.Name)
		constant.Doc = normalizeDoc(constant.GoName, constant.Doc)
	}

	t.Execute(wr, amqp.Constants)
}

func (amqp Amqp) SaveMethods(wr io.Writer) {
	const methodsTemplate = `
// Autogenerated code. Do not edit.
package amqp

import ( 
	"io"
	"errors"
	"fmt"
	"time"
)

type Method interface {
	Name() string
	FrameType() byte
	ClassIdentifier() uint16
	MethodIdentifier() uint16
	Read(reader io.Reader, protoVersion string) (err error)
	Write(writer io.Writer, protoVersion string) (err error)
	Sync() bool
}
{{range .}}
{{$classId := .ID}}
// {{.GoName}} methods

{{ if .Fields }}
type {{.GoName}}PropertyList struct {
{{range .Fields}}{{.GoName}} {{if ne .GoType "*Table"}}*{{end}}{{.GoType}}
{{end}}
}
func (pList *{{.GoName}}PropertyList) Read(reader io.Reader, propertyFlags uint16, protoVersion string) (err error) {
{{range .Fields}}
	if propertyFlags&(1<<{{.HeaderIndex}}) != 0 {
		value, err := Read{{.ReaderFunc}}(reader{{if eq .ReaderFunc "Table"}}, protoVersion{{end}})
		if err != nil {
			return err
		}
		pList.{{.GoName}} = {{if ne .GoType "*Table"}}&{{end}}value
	}
{{end}}
	return
}
func (pList *{{.GoName}}PropertyList) Write(writer io.Writer, protoVersion string) (propertyFlags uint16, err error) {
{{range .Fields}}
	if pList.{{.GoName}} != nil {
		propertyFlags |= 1 << {{.HeaderIndex}}
		if err = Write{{.ReaderFunc}}(writer, {{if ne .GoType "*Table"}}*{{end}}pList.{{.GoName}}{{if eq .ReaderFunc "Table"}}, protoVersion{{end}}); err != nil {
			return
		}
	}
{{end}}
	return
}
{{end}}
{{range .Methods}}
{{.Doc}} 
type {{.GoName}} struct {
{{range .Fields}}{{.GoName}} {{.GoType}}
{{end}}
}
// Name returns method name as string, usefully for logging
func (method *{{.GoName}}) Name() string {
    return "{{.GoName}}"
}

// FrameType returns method frame type
func (method *{{.GoName}}) FrameType() byte {
    return 1
}

// ClassIdentifier returns method classID
func (method *{{.GoName}}) ClassIdentifier() uint16 {
    return {{$classId}}
}

// MethodIdentifier returns method methodID
func (method *{{.GoName}}) MethodIdentifier() uint16 {
    return {{.ID}}
}

func (method *{{.GoName}}) Sync() bool {
    return {{if eq .Synchronous 1}}true{{else}}false{{end}}
} 

// Read method from io reader
func (method *{{.GoName}}) Read(reader io.Reader, protoVersion string) (err error) {
{{range .Fields}}
	{{if .IsBit }}
	{{if eq .BitOrder 0}}
		bits, err := ReadOctet(reader)
	{{end}}
		method.{{.GoName}} = bits&(1<<{{.BitOrder}}) != 0 
	{{else}}
	method.{{.GoName}}, err = Read{{.ReaderFunc}}(reader{{if eq .ReaderFunc "Table"}}, protoVersion{{end}})
	if err != nil {
		return err
	}
	{{end}}
    
{{end}}
	return
}

// Write method from io reader
func (method *{{.GoName}}) Write(writer io.Writer, protoVersion string) (err error) {
{{$bitFieldsStarted := false}}
{{range .Fields}}
	{{if .IsBit }}
	{{$bitFieldsStarted := true}}
	{{if eq .BitOrder 0}}
	var bits byte
	{{end}}
	if method.{{.GoName}} {
		bits |= 1 << {{.BitOrder}}
	}
	{{if .LastBit}}
	if err = WriteOctet(writer, bits); err != nil {
		return err
	}
	{{end}}
	{{else}}
	if err = Write{{.ReaderFunc}}(writer, method.{{.GoName}}{{if eq .ReaderFunc "Table"}}, protoVersion{{end}}); err != nil {
		return err
	}
	{{end}}
{{end}}
	return
}
{{end}}
{{end}}

// ReadMethod reads method from frame's payload
func ReadMethod(reader io.Reader, protoVersion string) (Method, error) {
	classId, err := ReadShort(reader)
	if err != nil {
		return nil, err 
	}

	methodId, err := ReadShort(reader)
	if err != nil {
		return nil, err 
	}
	switch classId {
		{{range .}}
	case {{.ID}}:
		switch methodId {
			{{range .Methods}}
		case {{.ID}}:
			var method = &{{.GoName}}{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil{{end}}
		}{{end}}
	}

	return nil, fmt.Errorf("Unknown classId and methodId: [%d. %d]", classId, methodId)
}

// WriteMethod writes method into frame's payload
func WriteMethod(writer io.Writer, method Method, protoVersion string) (err error) {
	if err = WriteShort(writer, method.ClassIdentifier()); err != nil {
		return err
	}
	if err = WriteShort(writer, method.MethodIdentifier()); err != nil {
		return err
	}

	if err = method.Write(writer, protoVersion); err != nil {
		return err
	}
	
	return
}
`
	t := template.Must(template.New("methodsTemplate").Parse(methodsTemplate))

	domainAliases := map[string]string{}

	for _, domain := range amqp.Domains {
		if _, ok := baseDomainsMap[domain.Name]; !ok {
			domainAliases[domain.Name] = domain.Type
		}
	}

	for _, class := range amqp.Classes {
		class.GoName = kebabToCamel(class.Name)

		headerIndex := 15
		for _, field := range class.Fields {
			field.GoName = kebabToCamel(field.Name)
			domainKey := calcDomainKey(field, domainAliases)
			field.GoType = baseDomainsMap[domainKey]
			field.ReaderFunc = kebabToCamel(domainKey)
			field.HeaderIndex = headerIndex
			headerIndex--
		}

		for _, method := range class.Methods {
			method.GoName = kebabToCamel(class.Name + "-" + method.Name)
			method.Doc = normalizeDoc(method.GoName, method.Doc)
			bitOrder := 0
			methodsCount := len(method.Fields)
			for idx, field := range method.Fields {
				field.LastBit = false
				field.GoName = kebabToCamel(field.Name)
				domainKey := calcDomainKey(field, domainAliases)
				field.GoType = baseDomainsMap[domainKey]
				field.IsBit = domainKey == "bit"
				if field.IsBit {
					field.BitOrder = bitOrder
					bitOrder++
				} else if bitOrder > 0 {
					method.Fields[idx-1].LastBit = true
					bitOrder = 0
				}

				if field.IsBit && methodsCount == idx+1 {
					method.Fields[idx].LastBit = true
					bitOrder = 0
				}

				field.ReaderFunc = kebabToCamel(domainKey)
			}
		}
	}

	t.Execute(wr, amqp.Classes)
}

func calcDomainKey(field *Field, domainAliases map[string]string) string {
	var domainKey string

	if field.Domain != "" {
		domainKey = field.Domain
	} else {
		domainKey = field.Type
	}
	if dk, ok := domainAliases[field.Domain]; ok {
		domainKey = dk
	}
	return domainKey
}

func main() {
	file, _ := ioutil.ReadFile("protocol/amqp0-9-1.extended.xml")
	var amqp Amqp
	xml.Unmarshal(file, &amqp)

	constantsFile, _ := os.Create("amqp/constants_generated.go")
	methodsFile, _ := os.Create("amqp/methods_generated.go")
	amqp.SaveConstants(constantsFile)
	amqp.SaveMethods(methodsFile)
	return
}

func kebabToCamel(kebab string) (camel string) {
	parts := strings.Split(kebab, "-")
	for _, part := range parts {
		camel += strings.Title(part)
	}
	return
}

func kebabToStr(kebab string) (str string) {
	parts := strings.Split(kebab, "-")
	upperParts := []string{}
	for _, part := range parts {
		upperParts = append(upperParts, strings.ToUpper(part))
	}
	return strings.Join(upperParts, "_")
}

func normalizeDoc(goName string, doc string) string {
	doc = strings.TrimSpace(doc)

	docLines := []string{}

	for idx, line := range strings.Split(doc, "\n") {
		line = strings.TrimSpace(line)
		if idx == 0 {
			line = goName + " " + line
		}
		line = "// " + line
		docLines = append(docLines, line)
	}
	return strings.Join(docLines, "\n")
}
